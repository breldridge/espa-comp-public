# Script for plotting the WECC model generation, demand, and transmissionimport matplotlib.pyplot as pltimport numpy as npimport pandas as pdimport jsonimport osfrom market_clearing.utils import data_utils as dumkt_type = 'TS'savedir = f'saved/{mkt_type}_market'sys_power = pd.read_csv(os.path.join(savedir,'system_power.csv'))sys_power['Time'] = pd.to_datetime(sys_power['Time'])ptime = Noneif ptime == None:    sys_line = sys_power.iloc[0,:]else:    sys_line = sys_power.iloc[sys_power['Time']==ptime,:]with open('ba_names.json', 'r') as f:    ba_names = json.load(f)ba_list = sorted(ba_names['ba'])# Load actual values for demand as well as for system capacityintervals = [(1, 5)]this_time = sys_line['Time'].strftime('%Y%m%d%H%M')base_demand = du.get_actual(None, intervals, mode='ba', rlist=['demand'], times=this_time)base_demand = base_demand['demand']# with open('scale_factors.json', 'r') as f:#     scale_factors = json.load(f)# sc_fd = scale_factors['flex_dem']sc_fd = 1.0peak_dem = 0for ba, value in base_demand.items():    new_value = [v*sc_fd for v in value]    if new_value[0] > peak_dem:        peak_dem = new_value[0]    base_demand[ba] = new_value[0]# Load topology info - has our chosen demand blockswith open('topology_conf.json', 'r') as f:    topology = json.load(f)dem_pcnt_block = topology['dem_block']['mq']dem_pcnt_block = np.cumsum(dem_pcnt_block)# Load transmission line capacity informationtlines = pd.read_excel('market_clearing/system_data/Transmission.xlsx', sheet_name='Clean_BA_Format')tline_dict = {}tline_sf = 1./topology["scaling"]for i in range(len(tlines.index)):    bas = tlines.loc[i,'transmission_line'].split('_')    tr_cap = tlines.loc[i,'max_mw']    bas = du.handle_TH(bas)    ba1, ba2 = bas    tline_dict[f'{ba1}_{ba2}'] = tr_cap*tline_sf# Select (somewhat arbitrary) positions to display all BAs (on 100x100 grid)with open('ba_positions.json', 'r') as f:    ba_pos = json.load(f)# Now plotfig = plt.figure(figsize=(10,10))# Plot transmission linestcolors = ['red', 'orange', 'green', 'blue']for tline, tr_cap in tline_dict.items():    if tline in sys_line.index:        tflow = sys_line[tline]    else:        tflow = 0    tflow_pcnt = abs(tflow)/tr_cap    print(tflow_pcnt, abs(tflow), tr_cap)    pcnts = [1.0, 0.95, 0.8, 0]    tflow_idx = np.argmax(pcnts<tflow_pcnt)    color = tcolors[tflow_idx]    if tflow_pcnt == 1:        color = 'k'    bas = tline.split('_')    bas = du.handle_TH(bas)    ba1, ba2 = bas    (x1, y1) = ba_pos[ba1]    (x2, y2) = ba_pos[ba2]    xarr = np.array([x1, x2])    yarr = np.array([y1, y2])    plt.plot(xarr, yarr, c=color)# Plot BA demand. Color indicates amount of flex (red=heavy flex, blue=no flex)# Size indicates relative demand (largest is highest load)colors = ['red', 'orange', 'yellow', 'green', 'blue']sizes = np.linspace(4,12,5)for ba in ba_list:    ba_dem = -sys_line[f'demand_{ba}']    ba_base = base_demand[ba]    if ba_base == 0:        ba_base = 1    flex_pcnt = ba_dem/ba_base    flex_idx = [i for i in range(len(dem_pcnt_block)) if flex_pcnt < dem_pcnt_block[i]]    if len(flex_idx) == 0:        flex_idx = 4    else:        flex_idx = flex_idx[-1]    color = colors[flex_idx]    if ba_base == 1:        color = 'blue'    peak_pcnt = ba_base/peak_dem    pcnts = np.arange(0,0.81,0.2)    peak_idx = np.argmax(pcnts>peak_pcnt)    sz = sizes[peak_idx]    (xp, yp) = ba_pos[ba]    plt.plot(xp,yp,c=color, mec='k',marker='o',ms=sz)plt.show()